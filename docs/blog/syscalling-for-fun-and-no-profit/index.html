<!DOCTYPE html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width, initial-scale=1"><title>doing bad things poorly</title><link rel=stylesheet href=/index.css><meta property=og:title content="doing bad things poorly"><meta property=og:description content="An expert in the field of doing things wrongly for over 20 years, Andrew Pan lends us his expertise in a series of long-form blog posts."><meta property=og:image content=/apple-touch-icon-180x180.png><meta property=og:url content=https://unown.me/blog/syscalling-for-fun-and-no-profit/><link rel=alternate type=application/atom+xml title=Atom href=https://unown.me/atom.xml><body class="bg-gray-900 text-gray-50"><div class="flex flex-col items-center w-3/4 max-w-screen-md min-h-stretch md:min-h-screen mx-auto divide-solid divide-y-2"><header class=w-full><nav class="p-4 text-2xl font-mono w-full"><ul class="m-auto w-full text-center md:text-right"><li class="mx-2 inline md:float-left"><a class=hover:underline href=/>home</a><li class="mx-2 inline"><a class="underline hover:no-underline"href=/blog>posts</a><li class="mx-2 inline"><a class=hover:underline href=/about>about</a><li class="mx-2 inline"><a class=hover:underline href=https://github.com/knownunown>github</a></ul></nav></header><main class="w-full pt-4 pb-4 flex-grow"><h1 class="text-3xl mb-2">syscalling for fun and (no) profit</h1><h3 class="my-2 text-gray-400">2021-02-28 | ~1688 words</h3><article class="prose prose-lg prose-dark prose-yellow max-w-max"><p>I recently had a (self-inflicted) problem in my <a href=https://www-users.cs.umn.edu/%7Ekauffman/4061/>Operating Systems course</a>. To expose us to the wonders of programming in a Unix environment, we were tasked with building a rudimentary "shell". To make the assignment more interesting to my partner and I, we decided to avoid <code>libc</code> and use Linux system calls directly <sup class=footnote-reference><a href=#1>1</a></sup>.</p><span id=continue-reading></span><h3 id=wait-what>wait, what?</h3><p>What does this even entail? On x86-64 Linux, the only platform this assignment needs to run on, it's easier than one would expect. Syscalls are distinguished by unique their <em>number</em> and the <em>arguments</em> they take. Linux syscalls are ABI-stable, which means that the behavior of any one syscall number is guaranteed to never change <sup class=footnote-reference><a href=#2>2</a></sup>. To invoke a syscall, one needs to:<ol><li>store the desired syscall <em>number</em> in <code>rax</code><li>pass a maximum of 6 <em>arguments</em> in registers <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>r10</code>, <code>r8</code>, and <code>r9</code><li>use the <code>syscall</code> instruction.</ol><p>Notice something familiar in step 2? That's the <a href=https://wiki.osdev.org/System_V_ABI#Calling_Convention>System V x86-64 calling convention</a>! We pass arguments into syscalls the same way that we pass arguments into normal function calls. The only difference is that instead of calling the function via the <code>call</code> instruction, we have to denote the syscall number via <code>rax</code> and invoke the syscall with the <code>syscall</code> instruction.<h2 id=zero-cost-abstractions>zero-cost abstractions</h2><p>Manually writing out all the <code>syscall</code> invocations for the syscalls that we needed to use felt a bit tedious. Instead, I decided to write a few functions abstracting over the required inline assembly, with which I generated syscall wrappers.<h3 id=a-false-start>a false start</h3><p>If you can play it slowly, you can play it quickly. I started small by implementing only one wrapper for a syscall with one argument. This was my initial attempt.<pre style=background-color:#2b303b;>
<code class=language-c data-lang=c><span style=color:#c0c5ce;>int64_t </span><span style=color:#8fa1b3;>syscall1</span><span style=color:#c0c5ce;>(</span><span style=color:#bf616a;>no</span><span style=color:#c0c5ce;>, </span><span style=color:#bf616a;>a1</span><span style=color:#c0c5ce;>) </span><span style=color:#b48ead;>register </span><span style=color:#c0c5ce;>int64_t no </span><span style=color:#b48ead;>asm</span><span style=color:#c0c5ce;>("</span><span style=color:#a3be8c;>rax</span><span style=color:#c0c5ce;>"); </span><span style=color:#b48ead;>register </span><span style=color:#c0c5ce;>int64_t a1 </span><span style=color:#b48ead;>asm</span><span style=color:#c0c5ce;>("</span><span style=color:#a3be8c;>rdi</span><span style=color:#c0c5ce;>"); { </span><span style=color:#b48ead;>asm volatile</span><span style=color:#c0c5ce;>("</span><span style=color:#a3be8c;>syscall</span><span style=color:#c0c5ce;>" : "</span><span style=color:#a3be8c;>+r</span><span style=color:#c0c5ce;>"(no) : "</span><span style=color:#a3be8c;>r</span><span style=color:#c0c5ce;>"(a1) : "</span><span style=color:#a3be8c;>rcx</span><span style=color:#c0c5ce;>", "</span><span style=color:#a3be8c;>r11</span><span style=color:#c0c5ce;>", "</span><span style=color:#a3be8c;>memory</span><span style=color:#c0c5ce;>"); </span><span style=color:#b48ead;>return</span><span style=color:#c0c5ce;> no; } </span></code></pre><p>Through previous projects, I learnt about <a href=https://gcc.gnu.org/onlinedocs/gcc/Local-Register-Variables.html#Local-Register-Variables>some GCC-specific trickery that allows us to control register allocation</a>. However, I wasn't able to declare function arguments as such.<pre style=background-color:#2b303b;>
<code class=language-c data-lang=c><span style=color:#b48ead;>static inline </span><span style=color:#c0c5ce;>int64_t </span><span style=color:#8fa1b3;>syscall1</span><span style=color:#c0c5ce;>(</span><span style=color:#b48ead;>register </span><span style=color:#c0c5ce;>int64_t no </span><span style=color:#b48ead;>asm</span><span style=color:#c0c5ce;>("</span><span style=color:#a3be8c;>rax</span><span style=color:#c0c5ce;>"), </span><span style=color:#b48ead;>register </span><span style=color:#c0c5ce;>int64_t a1 </span><span style=color:#b48ead;>asm</span><span style=color:#c0c5ce;>("</span><span style=color:#a3be8c;>rdx</span><span style=color:#c0c5ce;>")) </span></code></pre><p>The above is apparently NOT syntactically valid. To hack around that, I used <a href=https://en.wikipedia.org/wiki/C_(programming_language)#K&R_C>K&R style function declarations</a>. This compiles, but the <code>no</code> and <code>a1</code> arguments were not assigned to the registers I wanted them to be in.<figure><img src=Untitled.png alt="screenshot of incorrect disassembly"><figcaption>WTF?</figcaption></figure><p>Looking back, this result was not a surprise. Being able to control register allocation for function arguments blatantly breaks calling convention and would make things impossible to link. Besides, K&R function declaration syntax is incredibly cursed, not to mention deprecated. The question remains: how should we write these wrappers?<h3 id=the-kosher-way>the kosher way</h3><p>Trying to be cool and using <em>exotic compiler features</em> netted me a great deal of pain, so I just decided to do it "normally".<pre style=background-color:#2b303b;>
<code class=language-c data-lang=c><span style=color:#c0c5ce;>int64_t </span><span style=color:#8fa1b3;>syscall1</span><span style=color:#c0c5ce;>(int64_t </span><span style=color:#bf616a;>a1</span><span style=color:#c0c5ce;>, int64_t </span><span style=color:#bf616a;>no</span><span style=color:#c0c5ce;>) { </span><span style=color:#b48ead;>asm volatile</span><span style=color:#c0c5ce;>("</span><span style=color:#a3be8c;>movq %0, </span><span style=color:#d08770;>%%</span><span style=color:#a3be8c;>rax</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>syscall</span><span style=color:#c0c5ce;>" : "</span><span style=color:#a3be8c;>+g</span><span style=color:#c0c5ce;>"(no) </span><span style=color:#65737e;>// r/w: syscall number </span><span style=color:#c0c5ce;>: "</span><span style=color:#a3be8c;>r</span><span style=color:#c0c5ce;>"(a1) : "</span><span style=color:#a3be8c;>rcx</span><span style=color:#c0c5ce;>", "</span><span style=color:#a3be8c;>r11</span><span style=color:#c0c5ce;>", "</span><span style=color:#a3be8c;>memory</span><span style=color:#c0c5ce;>"); </span><span style=color:#b48ead;>return</span><span style=color:#c0c5ce;> no; } </span></code></pre><p>I decided to exploit the inherent similarity between the system call ABI and normal System V function calls. To ensure that the arguments are passed in the correct order, I moved the syscall number <code>no</code> argument to the end. In the event that there are more than 6 arguments in the wrapper <sup class=footnote-reference><a href=#3>3</a></sup>, the <code>no</code> argument overflows into memory. We <code>mov</code> the syscall number into <code>eax</code> where the kernel expects it, and likewise modify the register constraint for <code>no</code> to <code>+g</code> to reflect the possibility of it not being a register.<p><img src=https://unown.me/blog/syscalling-for-fun-and-no-profit/Untitled%201.png alt="screenshot of correct disassembly"><p>As you can see, this one seemed to generate valid code. I then wrote <code>syscall2</code> through <code>syscall6</code> with the same pattern, then got to work on generating the real syscall wrappers.<h2 id=generating-the-syscall-wrappers>generating the syscall wrappers</h2><p>Believe it or not, there is no central location which contains definitions for all the syscalls. Canonically, it is libc's responsibility to provide those wrappers. Their prototypes are split up across various arbitrarily named header files, with arguments and constants for those further split up into other header files. The best place to find prototypes and headers lies within the manpages, specifically section 2. Our task now is to parse those manpages and turn them into syscall definitions utilizing our assembly wrappers.<h3 id=into-the-belly-of-the-beast>into the belly of the beast</h3><p>The Linux manpages are generated with <code>groff</code>, an archaic typesetter. Optimally, we want to "parse" the original <code>groff</code> markup to get the data we need. Fortunately, <code>man</code> provides a mechanism to get the path of the markup files from which it displays its output: the <code>-w</code> flag <sup class=footnote-reference><a href=#4>4</a></sup>. Since this provides the path to gzipped markup, I had to <code>zcat</code> it to get the text. This yielded the following for <code>read(2)</code>:<pre style=background-color:#2b303b;>
<code><span style=color:#c0c5ce;>&LTsnip> .TH READ 2 2018-02-02 "Linux" "Linux Programmer's Manual" .SH NAME read \- read from a file descriptor .SH SYNOPSIS .nf .B #include &LTunistd.h> .PP .BI "ssize_t read(int " fd ", void *" buf ", size_t " count ); .fi .SH DESCRIPTION .BR read () attempts to read up to .I count bytes from file descriptor .I fd into the buffer starting at .IR buf . .PP &LTsnip> </span></code></pre><p>While archaic and not as nice when compared to asciidoc, this is workable with some judicious <code>sed</code> and my hammer of choice, fish shell.<h3 id=sed-to-the-rescue><code>sed</code> to the rescue</h3><p><code>groff</code> seems to have some semblance of structure in the form of sections. We can pinpoint and preprocess specific sections to work on with this <code>sed</code> snippet.<pre style=background-color:#2b303b;>
<code><span style=color:#c0c5ce;>/^\.SH SYNOPSIS/,/^\.SH.*/ { /^\.SH/D # delete section headers s/"|;//g # delete quotation marks, semis s/^\.[A-Za-z]+ *//g # delete preceding directives s/\/\*.+\*\///g # delete C89 comments p # print } </span></code></pre><p>The function prototypes and <code>#include</code> directives usually reside in the synopsis section, so we match for that with <code>/^\.SH SYNOPSIS/,/^\.SH.*/</code>. This matches ranges of lines beginning with a <code>.SH SYNOPSIS</code> and ending with any arbitrary <code>.SH</code> command, which denotes the next header. We specify multiple commands in the body of the sed match to clean up <code>groff</code> markup cruft, leaving only the <code>#include</code> and prototype.<pre style=background-color:#2b303b;>
<code><span style=color:#c0c5ce;>#include &LTunistd.h> ssize_t read(int fd , void * buf , size_t count ) </span></code></pre><p>Now that we have the prototype, the next issue is generating the call to the <code>syscall</code> wrapper. The only real challenge here is extricating the variable names from their types. This is achievable with some <code>grep</code>.<pre style=background-color:#2b303b;>
<code class=language-bash data-lang=bash><span style=color:#bf616a;>$</span><span style=color:#c0c5ce;> echo '</span><span style=color:#a3be8c;>ssize_t read(int fd , void * buf , size_t count )</span><span style=color:#c0c5ce;>' | </span><span style=color:#bf616a;>grep -oE </span><span style=color:#c0c5ce;>'</span><span style=color:#a3be8c;>[0-9a-zA-Z_]+ *(,|\))</span><span style=color:#c0c5ce;>' </span><span style=color:#bf616a;>fd</span><span style=color:#c0c5ce;> , </span><span style=color:#bf616a;>buf</span><span style=color:#c0c5ce;> , </span><span style=color:#bf616a;>count </span><span style=color:#c0c5ce;>) </span></code></pre><p>We still have some spurious tokens in there, but a quick pipe to <code>tr -d ',)'</code> solves that problem.<p>One more additional thing of interest is how we get the syscall number. Those are all defined in <code>sys/syscall.h</code> as macros, but where that file is located is entirely system-dependent. Luckily, we can make <code>gcc</code> do the work for us. The <code>-E -dM</code> flags, as <a href=https://stackoverflow.com/a/2224357>this StackOverflow answer</a> helpfully points out, dumps a list of all the preprocessor macros that are defined. We can then use <code>sed</code> with a capture group to grab the number.<pre style=background-color:#2b303b;>
<code class=language-bash data-lang=bash><span style=color:#bf616a;>$</span><span style=color:#c0c5ce;> echo '</span><span style=color:#a3be8c;>#include &LTsys/syscall.h></span><span style=color:#c0c5ce;>' | </span><span style=color:#bf616a;>gcc -E -dM -x</span><span style=color:#c0c5ce;> c - | </span><span style=color:#bf616a;>sed -En </span><span style=color:#c0c5ce;>"</span><span style=color:#a3be8c;>s/#define __NR_read +([0-9]+)/\1/p</span><span style=color:#c0c5ce;>" </span><span style=color:#bf616a;>0 </span></code></pre><p>With the argument names and syscall number we can munge together a call to the appropriate <code>syscall</code> wrapper in our function declaration (which we derive from the prototype). We can then generate a halfway sane header file <sup class=footnote-reference><a href=#5>5</a></sup>:<pre style=background-color:#2b303b;>
<code class=language-c data-lang=c><span style=color:#65737e;>// This file was generated by mklibsysc. </span><span style=color:#b48ead;>#ifndef</span><span style=color:#c0c5ce;> LIBSYSC_H_ </span><span style=color:#b48ead;>#define </span><span style=color:#c0c5ce;>LIBSYSC_H_ </span><span style=color:#b48ead;>#include </span><span style=color:#c0c5ce;><</span><span style=color:#a3be8c;>fcntl.h</span><span style=color:#c0c5ce;>> </span><span style=color:#b48ead;>#include </span><span style=color:#c0c5ce;><</span><span style=color:#a3be8c;>stdint.h</span><span style=color:#c0c5ce;>> </span><span style=color:#b48ead;>#include </span><span style=color:#c0c5ce;><</span><span style=color:#a3be8c;>unistd.h</span><span style=color:#c0c5ce;>> </span><span style=color:#65737e;>// &LTsnip: syscall0 ... syscall6> //$syscalls=read,write,dup,dup2,exit_group </span><span style=color:#b48ead;>#define </span><span style=color:#c0c5ce;>read libsysc_read </span><span style=color:#b48ead;>__attribute__</span><span style=color:#c0c5ce;>((noinline)) ssize_t </span><span style=color:#8fa1b3;>libsysc_read</span><span style=color:#c0c5ce;>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd </span><span style=color:#c0c5ce;>, </span><span style=color:#b48ead;>void </span><span style=color:#c0c5ce;>* </span><span style=color:#bf616a;>buf </span><span style=color:#c0c5ce;>, size_t </span><span style=color:#bf616a;>count </span><span style=color:#c0c5ce;>) { </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>syscall3 </span><span style=color:#c0c5ce;>( fd , buf , count , </span><span style=color:#d08770;>0 </span><span style=color:#c0c5ce;>); } </span><span style=color:#b48ead;>#define </span><span style=color:#c0c5ce;>write libsysc_write </span><span style=color:#b48ead;>__attribute__</span><span style=color:#c0c5ce;>((noinline)) ssize_t </span><span style=color:#8fa1b3;>libsysc_write</span><span style=color:#c0c5ce;>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>fd </span><span style=color:#c0c5ce;>, </span><span style=color:#b48ead;>const void </span><span style=color:#c0c5ce;>* </span><span style=color:#bf616a;>buf </span><span style=color:#c0c5ce;>, size_t </span><span style=color:#bf616a;>count </span><span style=color:#c0c5ce;>) { </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>syscall3 </span><span style=color:#c0c5ce;>( fd , buf , count , </span><span style=color:#d08770;>1 </span><span style=color:#c0c5ce;>); } </span><span style=color:#b48ead;>#define </span><span style=color:#c0c5ce;>dup libsysc_dup </span><span style=color:#b48ead;>__attribute__</span><span style=color:#c0c5ce;>((noinline)) </span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>libsysc_dup</span><span style=color:#c0c5ce;>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>oldfd </span><span style=color:#c0c5ce;>) { </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>syscall1 </span><span style=color:#c0c5ce;>( oldfd , </span><span style=color:#d08770;>32 </span><span style=color:#c0c5ce;>); } </span><span style=color:#b48ead;>#define </span><span style=color:#c0c5ce;>dup2 libsysc_dup2 </span><span style=color:#b48ead;>__attribute__</span><span style=color:#c0c5ce;>((noinline)) </span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>libsysc_dup2</span><span style=color:#c0c5ce;>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>oldfd </span><span style=color:#c0c5ce;>, </span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>newfd </span><span style=color:#c0c5ce;>) { </span><span style=color:#b48ead;>return </span><span style=color:#bf616a;>syscall2 </span><span style=color:#c0c5ce;>( oldfd , newfd , </span><span style=color:#d08770;>33 </span><span style=color:#c0c5ce;>); } </span><span style=color:#b48ead;>#define </span><span style=color:#c0c5ce;>exit_group libsysc_exit_group </span><span style=color:#b48ead;>__attribute__</span><span style=color:#c0c5ce;>((noinline)) </span><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>libsysc_exit_group</span><span style=color:#c0c5ce;>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>status </span><span style=color:#c0c5ce;>) { </span><span style=color:#bf616a;>syscall1 </span><span style=color:#c0c5ce;>( status , </span><span style=color:#d08770;>231 </span><span style=color:#c0c5ce;>); } </span><span style=color:#b48ead;>#endif </span><span style=color:#65737e;>// LIBSYSC_H_ </span></code></pre><p>This looks a bit ugly, but <code>clang-format</code> can fix it. Regardless, not bad for a shell script and some regex.<h2 id=trying-it-out>trying it out</h2><p>Now that we have all these syscall wrappers, it's time to write a program to test a few of them.<pre style=background-color:#2b303b;>
<code class=language-c data-lang=c><span style=color:#b48ead;>#include </span><span style=color:#c0c5ce;>"</span><span style=color:#a3be8c;>libsysc.h</span><span style=color:#c0c5ce;>" </span><span style=color:#bf616a;>asm</span><span style=color:#c0c5ce;>("</span><span style=color:#a3be8c;>.global _start</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>_start:</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>mov (%rsp), </span><span style=color:#d08770;>%e</span><span style=color:#a3be8c;>di</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>leaq 8(%rsp), %rsi</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>call main</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>mov $0, </span><span style=color:#d08770;>%e</span><span style=color:#a3be8c;>di</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>call libsysc_exit_group</span><span style=color:#96b5b4;>\n\t</span><span style=color:#c0c5ce;>" "</span><span style=color:#a3be8c;>syscall</span><span style=color:#c0c5ce;>"); </span><span style=color:#b48ead;>int </span><span style=color:#8fa1b3;>main</span><span style=color:#c0c5ce;>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>argc</span><span style=color:#c0c5ce;>, </span><span style=color:#b48ead;>char </span><span style=color:#c0c5ce;>*</span><span style=color:#bf616a;>argv</span><span style=color:#c0c5ce;>[]) { </span><span style=color:#b48ead;>char</span><span style=color:#c0c5ce;> buf[</span><span style=color:#d08770;>4</span><span style=color:#c0c5ce;>]; </span><span style=color:#b48ead;>if </span><span style=color:#c0c5ce;>(argc > </span><span style=color:#d08770;>0</span><span style=color:#c0c5ce;>) </span><span style=color:#65737e;>// lol </span><span style=color:#bf616a;>write</span><span style=color:#c0c5ce;>(</span><span style=color:#d08770;>1</span><span style=color:#c0c5ce;>, argv[</span><span style=color:#d08770;>0</span><span style=color:#c0c5ce;>], </span><span style=color:#d08770;>7</span><span style=color:#c0c5ce;>); </span><span style=color:#65737e;>// ./a.out </span><span style=color:#bf616a;>write</span><span style=color:#c0c5ce;>(</span><span style=color:#d08770;>1</span><span style=color:#c0c5ce;>, "</span><span style=color:#96b5b4;>\n</span><span style=color:#a3be8c;>Name: </span><span style=color:#c0c5ce;>", </span><span style=color:#d08770;>7</span><span style=color:#c0c5ce;>); </span><span style=color:#bf616a;>read</span><span style=color:#c0c5ce;>(</span><span style=color:#d08770;>0</span><span style=color:#c0c5ce;>, buf, </span><span style=color:#d08770;>4</span><span style=color:#c0c5ce;>); </span><span style=color:#bf616a;>write</span><span style=color:#c0c5ce;>(</span><span style=color:#d08770;>1</span><span style=color:#c0c5ce;>, "</span><span style=color:#a3be8c;>hello </span><span style=color:#c0c5ce;>", </span><span style=color:#d08770;>6</span><span style=color:#c0c5ce;>); </span><span style=color:#bf616a;>write</span><span style=color:#c0c5ce;>(</span><span style=color:#d08770;>1</span><span style=color:#c0c5ce;>, buf, </span><span style=color:#d08770;>4</span><span style=color:#c0c5ce;>); </span><span style=color:#bf616a;>write</span><span style=color:#c0c5ce;>(</span><span style=color:#d08770;>1</span><span style=color:#c0c5ce;>, "</span><span style=color:#a3be8c;>!</span><span style=color:#96b5b4;>\n</span><span style=color:#c0c5ce;>", </span><span style=color:#d08770;>2</span><span style=color:#c0c5ce;>); } </span></code></pre><p>That <code>asm</code> block at the beginning is some initialization code I stole <a href=https://stackoverflow.com/a/16722942>from StackOverflow</a> to replace the stdlib's built-in <code>_start</code> function that calls main. Roughly speaking, <code>argc</code> and <code>argv</code> is handed to the program on the stack, which we have to cram into the registers that <code>main</code> expects them in.<p>Now it's time to compile and run.<pre style=background-color:#2b303b;>
<code class=language-c data-lang=c><span style=color:#c0c5ce;>$ gcc -nostdlib -fno-stack-protector x.</span><span style=color:#bf616a;>c </span><span style=color:#d08770;>2</span><span style=color:#c0c5ce;>>/dev/null && echo '</span><span style=color:#a3be8c;>andrew</span><span style=color:#c0c5ce;>' | ./a.</span><span style=color:#bf616a;>out </span><span style=color:#c0c5ce;>./a.</span><span style=color:#bf616a;>out </span><span style=color:#c0c5ce;>Name: hello andr! </span></code></pre><p>ðŸ™‚<h3 id=future-work>future work</h3><p>I've learnt that programming without the standard library is painful <sup class=footnote-reference><a href=#6>6</a></sup>. Later in the semester, we will build our own minimal vaguely POSIX-compliant libc atop of our syscall wrappers. Watch this space!<div class=footnote-definition id=1><sup class=footnote-definition-label>1</sup><p>... which was the plan, until I didn't finish the syscall layer in time.</div><div class=footnote-definition id=2><sup class=footnote-definition-label>2</sup><p>On Linux anyways.</div><div class=footnote-definition id=3><sup class=footnote-definition-label>3</sup><p><code>syscall6</code>, the wrapper for syscalls with 6 arguments, has 7 arguments in total due to the <code>no</code> argument.</div><div class=footnote-definition id=4><sup class=footnote-definition-label>4</sup><p>You can read all about it by running <code>man man</code>.</div><div class=footnote-definition id=5><sup class=footnote-definition-label>5</sup><p><code>mklibsysc</code> only generates wrappers for syscalls specified in the input, which is why there are only 5 in the list.</div><div class=footnote-definition id=6><sup class=footnote-definition-label>6</sup><p>To be honest though, it's not that big of a downgrade when compared to libc.</div></article></main><footer class="p-4 text-gray-400">Content CC-BY-SA 4.0. Built with Zola and Nix. Revision <a class=hover:underline href=https://github.com/knownunown/website/commit/a736294>a736294</a>. <aside class=hidden>Void where prohibited. No warranty, express or implied. Phosphate free.</aside></footer></div>